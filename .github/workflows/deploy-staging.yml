name: Deploy to Staging

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag (commit SHA or version)'
        required: false
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug GitHub context
        run: |
          echo "Repository: ${{ github.repository }}"
          echo "Repository Owner: ${{ github.repository_owner }}"
          echo "Repository Name: ${{ github.repository }}"
          echo "Expected format: repo:${{ github.repository_owner }}/${{ github.event.repository.name }}:*"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}
          output-credentials: true

      - name: Set image tag
        id: set-tag
        run: |
          if [ -z "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      - name: Build and push backend (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./backend/Dockerfile.prod \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:latest \
            --push \
            ./backend

      - name: Increment version and build frontend (ARM64)
        env:
          VITE_API_URL: ${{ secrets.STAGING_VITE_API_URL }}
          VITE_AUTH_TENANT_ID: ${{ secrets.VITE_AUTH_TENANT_ID }}
          VITE_AUTH_CLIENT_ID: ${{ secrets.VITE_AUTH_CLIENT_ID }}
          VITE_AUTH_REDIRECT_URI: ${{ secrets.STAGING_VITE_AUTH_REDIRECT_URI }}
        run: |
          # Read current version
          CURRENT_VERSION=$(cat frontend/VERSION | tr -d '[:space:]')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse and increment version (semver patch)
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          # Write new version back
          echo "$NEW_VERSION" > frontend/VERSION
          echo "New version: $NEW_VERSION"
          
          # Build with new version
          docker buildx build --platform linux/arm64 \
            -f ./frontend/Dockerfile.prod \
            --build-arg VITE_API_URL=${{ env.VITE_API_URL }} \
            --build-arg VITE_AUTH_TENANT_ID=${{ env.VITE_AUTH_TENANT_ID }} \
            --build-arg VITE_AUTH_CLIENT_ID=${{ env.VITE_AUTH_CLIENT_ID }} \
            --build-arg VITE_AUTH_REDIRECT_URI=${{ env.VITE_AUTH_REDIRECT_URI }} \
            --build-arg VITE_APP_VERSION="$NEW_VERSION" \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:latest \
            --push \
            ./frontend
          
          # Commit version update back to repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add frontend/VERSION
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]" || exit 0
          git push || echo "Failed to push version update (non-critical)"

      - name: Get current backend task definition
        id: backend-task-def
        run: |
          # Get task definition from service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.STAGING_CLUSTER_NAME }} \
            --services ${{ secrets.STAGING_BACKEND_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new backend task definition
        id: register-backend
        run: |
          TASK_DEF=$(echo '${{ steps.backend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Get current frontend task definition
        id: frontend-task-def
        run: |
          # Get task definition from service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.STAGING_CLUSTER_NAME }} \
            --services ${{ secrets.STAGING_FRONTEND_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new frontend task definition
        id: register-frontend
        run: |
          TASK_DEF=$(echo '${{ steps.frontend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Create backend CodeDeploy deployment
        id: backend-deploy
        run: |
          APPSPEC=$(cat <<EOF
          {
            "version": 0.0,
            "Resources": [{
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-backend.outputs.task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "backend",
                    "ContainerPort": 4000
                  }
                }
              }
            }]
          }
          EOF
          )
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name ${{ secrets.STAGING_BACKEND_CODEDEPLOY_APP }} \
            --deployment-group-name ${{ secrets.STAGING_BACKEND_DEPLOYMENT_GROUP }} \
            --revision "revisionType=AppSpecContent,appSpecContent='${APPSPEC}'" \
            --query 'deploymentId' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Create frontend CodeDeploy deployment
        id: frontend-deploy
        run: |
          APPSPEC=$(cat <<EOF
          {
            "version": 0.0,
            "Resources": [{
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-frontend.outputs.task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "frontend",
                    "ContainerPort": 80
                  }
                }
              }
            }]
          }
          EOF
          )
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name ${{ secrets.STAGING_FRONTEND_CODEDEPLOY_APP }} \
            --deployment-group-name ${{ secrets.STAGING_FRONTEND_DEPLOYMENT_GROUP }} \
            --revision "revisionType=AppSpecContent,appSpecContent='${APPSPEC}'" \
            --query 'deploymentId' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Wait for backend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.backend-deploy.outputs.deployment_id }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Wait for frontend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.frontend-deploy.outputs.deployment_id }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Health check
        run: |
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name isms-staging-alb \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNSName`].OutputValue' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "Checking health at https://$ALB_DNS/api/health"
          curl -f https://$ALB_DNS/api/health || exit 1

