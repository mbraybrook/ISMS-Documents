name: Deploy to Staging

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag (commit SHA or version)'
        required: false
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set image tag
        id: set-tag
        run: |
          if [ -z "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      - name: Build and push backend (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./backend/Dockerfile.prod \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:latest \
            --push \
            ./backend

      - name: Build and push frontend (ARM64)
        env:
          VITE_API_URL: ${{ secrets.STAGING_VITE_API_URL }}
          VITE_AUTH_TENANT_ID: ${{ secrets.VITE_AUTH_TENANT_ID }}
          VITE_AUTH_CLIENT_ID: ${{ secrets.VITE_AUTH_CLIENT_ID }}
          VITE_AUTH_REDIRECT_URI: ${{ secrets.STAGING_VITE_AUTH_REDIRECT_URI }}
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./frontend/Dockerfile.prod \
            --build-arg VITE_API_URL=${{ env.VITE_API_URL }} \
            --build-arg VITE_AUTH_TENANT_ID=${{ env.VITE_AUTH_TENANT_ID }} \
            --build-arg VITE_AUTH_CLIENT_ID=${{ env.VITE_AUTH_CLIENT_ID }} \
            --build-arg VITE_AUTH_REDIRECT_URI=${{ env.VITE_AUTH_REDIRECT_URI }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:latest \
            --push \
            ./frontend

      - name: Get current backend task definition
        id: backend-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.STAGING_BACKEND_SERVICE }} \
            --query 'taskDefinition' \
            --output json)
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new backend task definition
        id: register-backend
        run: |
          TASK_DEF=$(echo '${{ steps.backend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Get current frontend task definition
        id: frontend-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.STAGING_FRONTEND_SERVICE }} \
            --query 'taskDefinition' \
            --output json)
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new frontend task definition
        id: register-frontend
        run: |
          TASK_DEF=$(echo '${{ steps.frontend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Create backend CodeDeploy deployment
        id: backend-deploy
        run: |
          APPSPEC=$(cat <<EOF
          {
            "version": 0.0,
            "Resources": [{
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-backend.outputs.task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "backend",
                    "ContainerPort": 4000
                  }
                }
              }
            }]
          }
          EOF
          )
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name ${{ secrets.STAGING_BACKEND_CODEDEPLOY_APP }} \
            --deployment-group-name ${{ secrets.STAGING_BACKEND_DEPLOYMENT_GROUP }} \
            --revision "revisionType=AppSpecContent,appSpecContent='${APPSPEC}'" \
            --query 'deploymentId' \
            --output text)
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Create frontend CodeDeploy deployment
        id: frontend-deploy
        run: |
          APPSPEC=$(cat <<EOF
          {
            "version": 0.0,
            "Resources": [{
              "TargetService": {
                "Type": "AWS::ECS::Service",
                "Properties": {
                  "TaskDefinition": "${{ steps.register-frontend.outputs.task_def_arn }}",
                  "LoadBalancerInfo": {
                    "ContainerName": "frontend",
                    "ContainerPort": 80
                  }
                }
              }
            }]
          }
          EOF
          )
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --application-name ${{ secrets.STAGING_FRONTEND_CODEDEPLOY_APP }} \
            --deployment-group-name ${{ secrets.STAGING_FRONTEND_DEPLOYMENT_GROUP }} \
            --revision "revisionType=AppSpecContent,appSpecContent='${APPSPEC}'" \
            --query 'deploymentId' \
            --output text)
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Wait for backend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.backend-deploy.outputs.deployment_id }}

      - name: Wait for frontend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.frontend-deploy.outputs.deployment_id }}

      - name: Health check
        run: |
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name isms-staging \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNSName`].OutputValue' \
            --output text)
          echo "Checking health at https://$ALB_DNS/api/health"
          curl -f https://$ALB_DNS/api/health || exit 1

