name: Deploy to Staging

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag (commit SHA or version)'
        required: false
        default: ''

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Debug GitHub context
        run: |
          echo "Repository: ${{ github.repository }}"
          echo "Repository Owner: ${{ github.repository_owner }}"
          echo "Repository Name: ${{ github.repository }}"
          echo "Expected format: repo:${{ github.repository_owner }}/${{ github.event.repository.name }}:*"
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}
          role-session-name: GitHubActions-${{ github.run_id }}
          output-credentials: true

      - name: Set image tag
        id: set-tag
        run: |
          if [ -z "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      - name: Build and push backend (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./backend/Dockerfile.prod \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:latest \
            --push \
            ./backend

      - name: Increment version and build frontend (ARM64)
        env:
          VITE_API_URL: ${{ secrets.STAGING_VITE_API_URL }}
          VITE_AUTH_TENANT_ID: ${{ secrets.VITE_AUTH_TENANT_ID }}
          VITE_AUTH_CLIENT_ID: ${{ secrets.VITE_AUTH_CLIENT_ID }}
          VITE_AUTH_REDIRECT_URI: ${{ secrets.STAGING_VITE_AUTH_REDIRECT_URI }}
        run: |
          # Read current version
          CURRENT_VERSION=$(cat frontend/VERSION | tr -d '[:space:]')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse and increment version (semver patch)
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          # Write new version back
          echo "$NEW_VERSION" > frontend/VERSION
          echo "New version: $NEW_VERSION"
          
          # Build with new version
          docker buildx build --platform linux/arm64 \
            -f ./frontend/Dockerfile.prod \
            --build-arg VITE_API_URL=${{ env.VITE_API_URL }} \
            --build-arg VITE_AUTH_TENANT_ID=${{ env.VITE_AUTH_TENANT_ID }} \
            --build-arg VITE_AUTH_CLIENT_ID=${{ env.VITE_AUTH_CLIENT_ID }} \
            --build-arg VITE_AUTH_REDIRECT_URI=${{ env.VITE_AUTH_REDIRECT_URI }} \
            --build-arg VITE_APP_VERSION="$NEW_VERSION" \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:staging \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:latest \
            --push \
            ./frontend
          
          # Commit version update back to repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add frontend/VERSION
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]" || exit 0
          git push || echo "Failed to push version update (non-critical)"

      - name: Get current backend task definition
        id: backend-task-def
        run: |
          # Get task definition from service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.STAGING_CLUSTER_NAME }} \
            --services ${{ secrets.STAGING_BACKEND_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new backend task definition
        id: register-backend
        run: |
          TASK_DEF=$(echo '${{ steps.backend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Get current frontend task definition
        id: frontend-task-def
        run: |
          # Get task definition from service
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.STAGING_CLUSTER_NAME }} \
            --services ${{ secrets.STAGING_FRONTEND_SERVICE }} \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new frontend task definition
        id: register-frontend
        run: |
          TASK_DEF=$(echo '${{ steps.frontend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Create backend CodeDeploy deployment
        id: backend-deploy
        run: |
          # Create AppSpec JSON file
          APPSPEC_FILE=$(mktemp)
          jq -n \
            --arg task_def "${{ steps.register-backend.outputs.task_def_arn }}" \
            '{
              "version": 0.0,
              "Resources": [{
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": $task_def,
                    "LoadBalancerInfo": {
                      "ContainerName": "backend",
                      "ContainerPort": 4000
                    }
                  }
                }
              }]
            }' > $APPSPEC_FILE
          
          # Create deployment input JSON with AppSpec content as a JSON string
          # The content field needs the AppSpec JSON as a string (not an object)
          DEPLOYMENT_INPUT_FILE=$(mktemp)
          APPSPEC_COMPACT=$(jq -c '.' $APPSPEC_FILE)
          jq -n \
            --arg appName "${{ secrets.STAGING_BACKEND_CODEDEPLOY_APP }}" \
            --arg dgName "${{ secrets.STAGING_BACKEND_DEPLOYMENT_GROUP }}" \
            --arg appSpecContent "$APPSPEC_COMPACT" \
            '{
              "applicationName": $appName,
              "deploymentGroupName": $dgName,
              "revision": {
                "revisionType": "AppSpecContent",
                "appSpecContent": {
                  "content": $appSpecContent
                }
              }
            }' > $DEPLOYMENT_INPUT_FILE
          
          rm $APPSPEC_FILE
          
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --cli-input-json file://$DEPLOYMENT_INPUT_FILE \
            --query 'deploymentId' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          rm $DEPLOYMENT_INPUT_FILE
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Create frontend CodeDeploy deployment
        id: frontend-deploy
        run: |
          # Create AppSpec JSON file
          APPSPEC_FILE=$(mktemp)
          jq -n \
            --arg task_def "${{ steps.register-frontend.outputs.task_def_arn }}" \
            '{
              "version": 0.0,
              "Resources": [{
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": $task_def,
                    "LoadBalancerInfo": {
                      "ContainerName": "frontend",
                      "ContainerPort": 80
                    }
                  }
                }
              }]
            }' > $APPSPEC_FILE
          
          # Create deployment input JSON with AppSpec content as a JSON string
          # The content field needs the AppSpec JSON as a string (not an object)
          DEPLOYMENT_INPUT_FILE=$(mktemp)
          APPSPEC_COMPACT=$(jq -c '.' $APPSPEC_FILE)
          jq -n \
            --arg appName "${{ secrets.STAGING_FRONTEND_CODEDEPLOY_APP }}" \
            --arg dgName "${{ secrets.STAGING_FRONTEND_DEPLOYMENT_GROUP }}" \
            --arg appSpecContent "$APPSPEC_COMPACT" \
            '{
              "applicationName": $appName,
              "deploymentGroupName": $dgName,
              "revision": {
                "revisionType": "AppSpecContent",
                "appSpecContent": {
                  "content": $appSpecContent
                }
              }
            }' > $DEPLOYMENT_INPUT_FILE
          
          rm $APPSPEC_FILE
          
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --cli-input-json file://$DEPLOYMENT_INPUT_FILE \
            --query 'deploymentId' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          rm $DEPLOYMENT_INPUT_FILE
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Wait for backend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.backend-deploy.outputs.deployment_id }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Wait for frontend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.frontend-deploy.outputs.deployment_id }} \
            --region ${{ secrets.AWS_REGION }}

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name isms-staging-alb \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNSName`].OutputValue' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          # Check if custom domain is configured (from STAGING_VITE_API_URL)
          # If available, use it with HTTPS; otherwise use HTTP with ALB DNS
          if [ -n "${{ secrets.STAGING_VITE_API_URL }}" ]; then
            # Extract domain from URL (remove https:// and trailing /)
            HEALTH_URL="${{ secrets.STAGING_VITE_API_URL }}/api/health"
            echo "Checking health at $HEALTH_URL"
            curl -f "$HEALTH_URL" || exit 1
          else
            # Use HTTP with ALB DNS (certificate is for custom domain, not ALB DNS)
            echo "Checking health at http://$ALB_DNS/api/health"
            curl -f "http://$ALB_DNS/api/health" || exit 1
          fi

