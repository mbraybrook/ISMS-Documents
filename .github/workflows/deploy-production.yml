name: Deploy to Production

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Image tag (commit SHA or version)'
        required: false
        default: ''
      skip_staging:
        description: 'Skip staging deployment'
        required: false
        type: boolean
        default: false

jobs:
  deploy-staging:
    if: ${{ !inputs.skip_staging }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Trigger staging deployment
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'deploy-staging.yml',
              ref: context.sha
            })

      - name: Wait for staging deployment
        run: |
          echo "Waiting for staging deployment to complete..."
          sleep 60

  deploy-production:
    needs: deploy-staging
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-staging.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Set image tag
        id: set-tag
        run: |
          if [ -z "${{ inputs.image_tag }}" ]; then
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ inputs.image_tag }}" >> $GITHUB_OUTPUT
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Configure Docker for ECR
        run: |
          aws ecr get-login-password --region ${{ secrets.AWS_REGION }} | docker login --username AWS --password-stdin ${{ secrets.ECR_REGISTRY }}

      - name: Build and push backend (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./backend/Dockerfile.prod \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:production \
            -t ${{ secrets.ECR_REGISTRY }}/isms-backend:latest \
            --push \
            ./backend

      - name: Build and push document-service (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./services/document-service/Dockerfile \
            -t ${{ secrets.ECR_REGISTRY }}/isms-document-service:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-document-service:production \
            -t ${{ secrets.ECR_REGISTRY }}/isms-document-service:latest \
            --push \
            ./services/document-service

      - name: Build and push ai-service (ARM64)
        run: |
          docker buildx build --platform linux/arm64 \
            -f ./services/ai-service/Dockerfile \
            -t ${{ secrets.ECR_REGISTRY }}/isms-ai-service:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-ai-service:production \
            -t ${{ secrets.ECR_REGISTRY }}/isms-ai-service:latest \
            --push \
            ./services/ai-service

      - name: Increment version and build frontend (ARM64)
        env:
          VITE_API_URL: ${{ secrets.PRODUCTION_VITE_API_URL }}
          VITE_AUTH_TENANT_ID: ${{ secrets.VITE_AUTH_TENANT_ID }}
          VITE_AUTH_CLIENT_ID: ${{ secrets.VITE_AUTH_CLIENT_ID }}
          VITE_AUTH_REDIRECT_URI: ${{ secrets.PRODUCTION_VITE_AUTH_REDIRECT_URI }}
        run: |
          # Read current version
          CURRENT_VERSION=$(cat frontend/VERSION | tr -d '[:space:]')
          echo "Current version: $CURRENT_VERSION"
          
          # Parse and increment version (semver patch)
          MAJOR=$(echo "$CURRENT_VERSION" | cut -d. -f1)
          MINOR=$(echo "$CURRENT_VERSION" | cut -d. -f2)
          PATCH=$(echo "$CURRENT_VERSION" | cut -d. -f3)
          PATCH=$((PATCH + 1))
          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          
          # Write new version back
          echo "$NEW_VERSION" > frontend/VERSION
          echo "New version: $NEW_VERSION"
          
          # Build with new version
          docker buildx build --platform linux/arm64 \
            -f ./frontend/Dockerfile.prod \
            --build-arg VITE_API_URL=${{ env.VITE_API_URL }} \
            --build-arg VITE_AUTH_TENANT_ID=${{ env.VITE_AUTH_TENANT_ID }} \
            --build-arg VITE_AUTH_CLIENT_ID=${{ env.VITE_AUTH_CLIENT_ID }} \
            --build-arg VITE_AUTH_REDIRECT_URI=${{ env.VITE_AUTH_REDIRECT_URI }} \
            --build-arg VITE_APP_VERSION="$NEW_VERSION" \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }} \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:production \
            -t ${{ secrets.ECR_REGISTRY }}/isms-frontend:latest \
            --push \
            ./frontend
          
          # Commit version update back to repo
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add frontend/VERSION
          git commit -m "chore: bump version to $NEW_VERSION [skip ci]" || exit 0
          git push || echo "Failed to push version update (non-critical)"

      - name: Get current backend task definition
        id: backend-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.PRODUCTION_BACKEND_SERVICE }} \
            --query 'taskDefinition' \
            --output json)
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new backend task definition
        id: register-backend
        run: |
          TASK_DEF=$(echo '${{ steps.backend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-backend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Get current frontend task definition
        id: frontend-task-def
        run: |
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition ${{ secrets.PRODUCTION_FRONTEND_SERVICE }} \
            --query 'taskDefinition' \
            --output json)
          echo "task_def<<EOF" >> $GITHUB_OUTPUT
          echo "$TASK_DEF" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Register new frontend task definition
        id: register-frontend
        run: |
          TASK_DEF=$(echo '${{ steps.frontend-task-def.outputs.task_def }}' | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-frontend:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          NEW_TASK_DEF=$(aws ecs register-task-definition \
            --cli-input-json "$TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          echo "task_def_arn=$NEW_TASK_DEF" >> $GITHUB_OUTPUT

      - name: Create backend CodeDeploy deployment
        id: backend-deploy
        run: |
          # Create AppSpec JSON file
          APPSPEC_FILE=$(mktemp)
          jq -n \
            --arg task_def "${{ steps.register-backend.outputs.task_def_arn }}" \
            '{
              "version": 0.0,
              "Resources": [{
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": $task_def,
                    "LoadBalancerInfo": {
                      "ContainerName": "backend",
                      "ContainerPort": 4000
                    }
                  }
                }
              }]
            }' > $APPSPEC_FILE
          
          # Create deployment input JSON with AppSpec content as a JSON string
          # The content field needs the AppSpec JSON as a string (not an object)
          DEPLOYMENT_INPUT_FILE=$(mktemp)
          APPSPEC_COMPACT=$(jq -c '.' $APPSPEC_FILE)
          jq -n \
            --arg appName "${{ secrets.PRODUCTION_BACKEND_CODEDEPLOY_APP }}" \
            --arg dgName "${{ secrets.PRODUCTION_BACKEND_DEPLOYMENT_GROUP }}" \
            --arg appSpecContent "$APPSPEC_COMPACT" \
            '{
              "applicationName": $appName,
              "deploymentGroupName": $dgName,
              "revision": {
                "revisionType": "AppSpecContent",
                "appSpecContent": {
                  "content": $appSpecContent
                }
              }
            }' > $DEPLOYMENT_INPUT_FILE
          
          rm $APPSPEC_FILE
          
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --cli-input-json file://$DEPLOYMENT_INPUT_FILE \
            --query 'deploymentId' \
            --output text)
          
          rm $DEPLOYMENT_INPUT_FILE
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Create frontend CodeDeploy deployment
        id: frontend-deploy
        run: |
          # Create AppSpec JSON file
          APPSPEC_FILE=$(mktemp)
          jq -n \
            --arg task_def "${{ steps.register-frontend.outputs.task_def_arn }}" \
            '{
              "version": 0.0,
              "Resources": [{
                "TargetService": {
                  "Type": "AWS::ECS::Service",
                  "Properties": {
                    "TaskDefinition": $task_def,
                    "LoadBalancerInfo": {
                      "ContainerName": "frontend",
                      "ContainerPort": 80
                    }
                  }
                }
              }]
            }' > $APPSPEC_FILE
          
          # Create deployment input JSON with AppSpec content as a JSON string
          # The content field needs the AppSpec JSON as a string (not an object)
          DEPLOYMENT_INPUT_FILE=$(mktemp)
          APPSPEC_COMPACT=$(jq -c '.' $APPSPEC_FILE)
          jq -n \
            --arg appName "${{ secrets.PRODUCTION_FRONTEND_CODEDEPLOY_APP }}" \
            --arg dgName "${{ secrets.PRODUCTION_FRONTEND_DEPLOYMENT_GROUP }}" \
            --arg appSpecContent "$APPSPEC_COMPACT" \
            '{
              "applicationName": $appName,
              "deploymentGroupName": $dgName,
              "revision": {
                "revisionType": "AppSpecContent",
                "appSpecContent": {
                  "content": $appSpecContent
                }
              }
            }' > $DEPLOYMENT_INPUT_FILE
          
          rm $APPSPEC_FILE
          
          DEPLOYMENT_ID=$(aws deploy create-deployment \
            --cli-input-json file://$DEPLOYMENT_INPUT_FILE \
            --query 'deploymentId' \
            --output text)
          
          rm $DEPLOYMENT_INPUT_FILE
          echo "deployment_id=$DEPLOYMENT_ID" >> $GITHUB_OUTPUT

      - name: Wait for backend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.backend-deploy.outputs.deployment_id }}

      - name: Wait for frontend deployment
        run: |
          aws deploy wait deployment-successful \
            --deployment-id ${{ steps.frontend-deploy.outputs.deployment_id }}

      - name: Update document-service
        run: |
          # Get current task definition for document service
          SERVICE_NAME="isms-production-document-service"
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.PRODUCTION_CLUSTER_NAME }} \
            --services $SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }} 2>/dev/null || echo "")
          
          if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" == "None" ]; then
            echo "Document service not found. Skipping update (deploy via CloudFormation first)."
            exit 0
          fi
          
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          
          # Update image and register new revision
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-document-service:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster ${{ secrets.PRODUCTION_CLUSTER_NAME }} \
            --service $SERVICE_NAME \
            --task-definition $NEW_TASK_DEF_ARN \
            --region ${{ secrets.AWS_REGION }} \
            --output text
          
          echo "Document service updated with new task definition: $NEW_TASK_DEF_ARN"

      - name: Update ai-service
        run: |
          # Get current task definition for AI service
          SERVICE_NAME="isms-production-ai-service"
          TASK_DEF_ARN=$(aws ecs describe-services \
            --cluster ${{ secrets.PRODUCTION_CLUSTER_NAME }} \
            --services $SERVICE_NAME \
            --query 'services[0].taskDefinition' \
            --output text \
            --region ${{ secrets.AWS_REGION }} 2>/dev/null || echo "")
          
          if [ -z "$TASK_DEF_ARN" ] || [ "$TASK_DEF_ARN" == "None" ]; then
            echo "AI service not found. Skipping update (deploy via CloudFormation first)."
            exit 0
          fi
          
          # Get full task definition JSON
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition $TASK_DEF_ARN \
            --query 'taskDefinition' \
            --output json \
            --region ${{ secrets.AWS_REGION }})
          
          # Update image and register new revision
          NEW_TASK_DEF=$(echo "$TASK_DEF" | jq \
            --arg IMAGE "${{ secrets.ECR_REGISTRY }}/isms-ai-service:${{ steps.set-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)')
          
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json "$NEW_TASK_DEF" \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          # Update service with new task definition
          aws ecs update-service \
            --cluster ${{ secrets.PRODUCTION_CLUSTER_NAME }} \
            --service $SERVICE_NAME \
            --task-definition $NEW_TASK_DEF_ARN \
            --region ${{ secrets.AWS_REGION }} \
            --output text
          
          echo "AI service updated with new task definition: $NEW_TASK_DEF_ARN"

      - name: Health check
        run: |
          # Get ALB DNS name
          ALB_DNS=$(aws cloudformation describe-stacks \
            --stack-name isms-production \
            --query 'Stacks[0].Outputs[?OutputKey==`LoadBalancerDNSName`].OutputValue' \
            --output text \
            --region ${{ secrets.AWS_REGION }})
          
          # Check if custom domain is configured (from PRODUCTION_VITE_API_URL)
          # If available, use it with HTTPS; otherwise use HTTP with ALB DNS
          if [ -n "${{ secrets.PRODUCTION_VITE_API_URL }}" ]; then
            # Extract domain from URL (remove https:// and trailing /)
            HEALTH_URL="${{ secrets.PRODUCTION_VITE_API_URL }}/api/health"
            echo "Checking health at $HEALTH_URL"
            curl -f "$HEALTH_URL" || exit 1
          else
            # Use HTTP with ALB DNS (certificate is for custom domain, not ALB DNS)
            echo "Checking health at http://$ALB_DNS/api/health"
            curl -f "http://$ALB_DNS/api/health" || exit 1
          fi



